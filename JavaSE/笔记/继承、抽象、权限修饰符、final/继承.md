# 继承

#### 概述

- 继承是面向对象三大特征之一，继承就是子类继承父类的特征（属性）和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

- 继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。在令子类继承父类的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。

- 总结：

	- 子类继承父类可以获得父类的功能，提高代码的复用性
	- 子类可以重写（覆盖）某些父类的功能，我们一般称为增强
	- 子类除了可以继承父类的功能之外，还可以额外添加子类独有的功能，一般来说，子类要比父类强大（你的是我的，我的还是我的);

	

**继承的格式**

通过 `extends` 关键字，可以声明一个子类继承另外一个父类



#### **性质**

**父类不可被继承的内容**

并不是父类的所有内容都可以给子类继承的，以下两个个内容不能被子类继承：

- 被private修饰的
- 构造方法不能继承

> tips：虽然被private修饰的成员不能被继承下来，但是通过getter/setter方法访问父类的private成员变量



**成员变量的继承**

- 当子类父类中出现**不重名**的成员变量，这时的访问是**没有影响**的；
- 当子类父类中出现**重名**的成员变量，这时的访问是**有影响**的，默认取子类的（就近原则）；



**成员方法的继承**

- 如果子类和父类中出现**不重名**的成员方法，这时的调用是**没有影响**的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法；
- 如果子类父类中出现**重名**的成员方法，这时的访问是一种特殊情况，叫做方法**重写 (Override)**。
	- **方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为**重写**或者**复写**。声明不变，重新实现。



**构造方法的继承**

- 构造方法的名字是与类名一致的。**所以子类是无法继承父类构造方法的**。
- 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 `super()` ，表示调用父类的构造方法，**父类成员变量初始化后，才可以给子类使用。**
- **继承后子类构造方法特点：子类所有构造方法都会调用父类的无参构造**

> tips：子类在继承父类时，必须保证父类有无参构造方法，否则编译报错；



#### Super关键字

**super的作用**

- 在子类继承父类时，如果子类中的成员变量名称和父类的冲突时，那么默认情况下是取子类的成员变量；但是继承自父类的成员变量该怎么获取呢？
- 在子类继承父类时，子类方法名和父类方法名冲突了，我们知道会出现重写（Override），但此时如果需要调用父类的成员方法该怎么办呢？

`super`关键字：用于修饰父类成员变量，类似于之前学过的 `this` ；`this`代表的是本类对象，而`super`代表的是父类对象；使用`super`我们可以调用父类的成员（属性和行为），注意`super`关键字不能访问父类私有（private修饰）的成员

子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量（不是private修饰的）时，需要使用 `super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。

**super的关键字的作用如下**：

- 用于访问父类中定义的属性
- 用于调用父类中定义的成员方法
- 用于在子类构造方法中调用父类的构造器

**this和super访问构造方法**

我们知道子类的每个构造方法中均有默认的`super()`，调用父类的空参构造。手动调用父类构造会覆盖默认的`super()`；`super()` 和` this()` 都必须是在构造方法的第一行，所以不能同时出现。



#### 继承的特点

##### 继承问题

- 在Java中，不支持多继承，只支持单继承，但支持多重继承；即A继承B，B继承C，这样下来A间接继承与C；
- Java只支持单继承，不支持多继承
- 一个类可以有多个子类
- Java支持多层继承

##### 砖石问题

- 简介：钻石问题（diamond problem）指的是在多继承中，多个父类拥有同名方法时，子类继承时的问题；



##### static继承的特点

static修饰的成员是可以被继承到子类的；







