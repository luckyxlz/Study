# 继承、抽象、权限修饰符、final

## 继承

#### 继承概述

- 继承是面向对象三大特征之一，继承就是子类继承父类的特征（属性）和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

- 继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。



- 总结：
  - 子类继承父类可以获得父类的功能，提高代码的复用性
  - 子类可以重写（覆盖）某些父类的功能，我们一般称为增强
  - 子类除了可以继承父类的功能之外，还可以额外添加子类独有的功能，一般来说，子类要比父类强大（你的是我的，我的还是我的);

#### 继承的格式

通过 `extends` 关键字，可以声明一个子类继承另外一个父类

#### 父类不可被继承的内容

并不是父类的所有内容都可以给子类继承的，以下2个内容不能被子类继承：

- 被private修饰的
- 构造方法不能继承

> tips：虽然被private修饰的成员不能被继承下来，但是通过getter/setter方法访问父类的private成员变量

#### 成员变量的继承

- 当子类父类中出现**不重名**的成员变量，这时的访问是**没有影响**的；
- 当子类父类中出现**重名**的成员变量，这时的访问是**有影响**的，默认取子类的（就近原则）；

#### 成员方法的继承

- 如果子类和父类中出现**不重名**的成员方法，这时的调用是**没有影响**的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法；
- 如果子类父类中出现**重名**的成员方法，这时的访问是一种特殊情况，叫做方法**重写 (Override)**。
  - **方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为**重写**或者**复写**。声明不变，重新实现。

#### 构造方法的继承

- 构造方法的名字是与类名一致的。**所以子类是无法继承父类构造方法的**。
- 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 `super()` ，表示调用父类的构造方法，**父类成员变量初始化后，才可以给子类使用。**
- **继承后子类构造方法特点：子类所有构造方法都会调用父类的无参构造**

> tips：子类在继承父类时，必须保证父类有无参构造方法，否则编译报错；

#### Super关键字

##### super的作用

- 在子类继承父类时，如果子类中的成员变量名称和父类的冲突时，那么默认情况下是取子类的成员变量；但是继承自父类的成员变量该怎么获取呢？
- 在子类继承父类时，子类方法名和父类方法名冲突了，我们知道会出现重写（Override），但此时如果需要调用父类的成员方法该怎么办呢？

`super`关键字：用于修饰父类成员变量，类似于之前学过的 `this` ；`this`代表的是本类对象，而`super`代表的是父类对象；使用`super`我们可以调用父类的成员（属性和行为），注意`super`关键字不能访问父类私有（private修饰）的成员

子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量（不是private修饰的）时，需要使用 `super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。

**super的关键字的作用如下**：

- 用于访问父类中定义的属性
- 用于调用父类中定义的成员方法
- 用于在子类构造方法中调用父类的构造器

##### this和super访问构造方法

我们知道子类的每个构造方法中均有默认的`super()`，调用父类的空参构造。手动调用父类构造会覆盖默认的`super()`；`super()` 和` this()` 都必须是在构造方法的第一行，所以不能同时出现。

#### 继承的特点

##### 继承问题

- 在Java中，不支持多继承，只支持单继承，但支持多重继承；即A继承B，B继承C，这样下来C间接继承与A；
- Java只支持单继承，不支持多继承
- 一个类可以有多个子类
- Java支持多继承

##### 砖石问题

- 简介：钻石问题（diamond problem）指的是在多继承中，多个父类拥有同名方法时，子类继承时的问题；

##### static 继承的特点

static修饰的成员是可以被继承到子类的；











## 抽象

#### 抽象类概述

在继承体系中，由于父类的设计应该保证继承体系中所有子类的共性，子类往往比父类要描述的更加清晰、具体；因此我们有时需要将父类设计的抽象化；即方法只声明方法体，而没有方法具体功能，我们把没有方法主体的方法称为**抽象方法**。**包含抽象方法的类就是抽象类**。

#### 定义

- 抽象方法 ：没有方法体的方法。
- 抽象类：包含抽象方法的类。

#### abstract使用格式

使用 `abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

#### 抽象的使用

1）继承抽象类的子类**必须重写父类所有的抽象方法**。否则，该子类也必须声明为抽象类。

2）必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

> 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做**实现方法**。

#### 抽象类使用注意事项

- 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
- 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
- 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。







## 权限修饰符

### 概述

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的

|                             | public | protected | default | Private |
| --------------------------- | ------ | --------- | ------- | ------- |
| 同一类中                    | √      | √         | √       | √       |
| 同一包中(子类或任意类)      | √      | √         | √       |         |
| 不同包的子类(通过super访问) | √      | √         |         |         |
| 不同包的任意类              | √      |           |         |         |

#### 权限修饰符和方法的重写

在继承那一章节我们学习过方法的重写，当子类继承父类时，我们可以重新父类的方法，使其更加强大；

但是方法的重写必须保证子类方法的权限修饰符>=父类方法的权限修饰符；







## final关键字

#### 简介

fianl是Java中的一个关键字，中文含义是"最终的"，fianl可以修饰类、方法、变量等；

#### 特点

- final修饰的类不能被继承。提高安全性，提高程序的可读性；
- final修饰的方法不能被子类重写；
- final修饰的变量（成员变量或局部变量）只能被赋值一次；因此被final修饰的变量我们称为常量，**通常全大写命名；**