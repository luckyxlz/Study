# 泛型

#### 泛型概述

泛型定义：**把类型明确的工作延迟到创建对象或调用方法的时候才去明确的特殊的类型；**

### 集合泛型的使用

#### 使用泛型

集合的定义者发现，无法在定义集合类时就确定该集合存储的具体类型，因此使用泛型进行占位，使用者创建集合时明确该泛型的类型；

> Tips：在创建对象时指定泛型的类型，泛型一旦指定了具体的类型，原来泛型的占位符（E），都将变为此类型；

### 泛型类

#### 泛型类的使用

`Collection`、`List`、`Set`以及其下的子类都是泛型类，我们根据使用情况也可以定义泛型类；**让泛型类的类型延迟到创建对象的时候指定；**

##### 使用格式：

```java
修饰符 class 类名<代表泛型的变量> {}
```

#### 泛型类的继承

- 定义类时确定泛型的类型
- 始终不确定泛型的类型，直到创建对象时，确定泛型的类型
  - 子类也变为泛型类，泛型类型具体到创建对象的时候再确定
  
  

### 泛型方法

泛型类是在创建类时定义泛型类型，在创建对象时确定泛型类型；泛型方法则是**在创建方法是定义泛型类型，在调用方法时确定泛型类型；**

- 定义格式

  - ```java
    修饰符 <代表泛型的变量> 返回值类型 方法名(参数){}
    ```

    

### 泛型通配符

#### 通配符的使用

- 参数列表带有泛型

  - 泛型在程序运行中全部会被擦除，我们把这种现象称为泛型擦除；但编译时期**在使用泛型类进行方法传参时，不仅要匹配参数本身的类型，还要匹配泛型的类型；**

- 泛型通配符

  - 泛型的通配符：**不知道使用什么类型来接收的时候，此时可以使用?，?表示未知通配符。**

  - > Tips：需要注意的是，被<?>接收过的类型都将提升为Object类型；

#### 泛型上下边界

利用泛型通配符`?`可以接收任意泛型，但是随之而然带来一个问题，就是所有类型都提升为Object；范围太广了，使用起来非常不方便，因此为了让泛型也可以利用多态的特点，泛型的上下边界的概念由此引出；

利用泛型的通配符可以指定泛型的边界；

利用泛型的通配符可以指定泛型的边界；

**泛型的上限**：

- **格式**： `类型名称 <? extends 类> 对象名称`
- **含义**： `只能接收该类型及其子类`

**泛型的下限**：

- **格式**： `类型名称 <? super 类> 对象名称`
- **含义**： `只能接收该类型及其父类型`



