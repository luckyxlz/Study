## AOP工作流程

1. Spring容器启动
2. 读取所有切面配置中切入点
3. 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点
   - 匹配失败，创建对象
   - 匹配成功，创建原始对象的代理对象
4. 获取bean执行方法
   - 获取bean，调用方法并执行，完成操作
   - 获取b的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作

#### 核心概念

- 目标对象：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作
- 代理：目标对象无法直接完成，需要对其进行功能回填，通过原始对象的代理对象



## APP切入点表达式

- 切入点：要进行增强的方法
- 切入点表达式：要进行增强的方法的描述方式
- 描述方法
  - 执行com.lucky.dao.BookDao.update()
  - 执行com.lucky.dao.impl.BookDaoImpl.update()
- 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数)异常名)
  - 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点
  - 访问修饰符：public，private等，可以省略
  - 返回值
  - 包名
  - 类/接口名
  - 方法名
  - 参数
  - 异常名：方法定义中抛出指定异常，可以省略
- 可以使用通配符描述切入点，快速描述
  - *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现
  - ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写
  - +：专用于匹配子类类型
- 书写技巧
  - 所有代码按照标准规范开发，否则一下技巧全部失效
  - 描述切入点通常描述接口，而不描述类
  - 访问控制修饰符针对接口开发均采用public描述
  - 返回值类型对于增删改类使用精准类型加速匹配，对于查询列使用*通配快速描述
  - 包名书写尽量不使用..匹配，效率过低，常用“做单个包描述匹配，或精准匹配
  - 接口名/类名书写名称与模块相关的采用*匹配，例如UserService书写成\*Service，绑定业务层接口名
  - 方法名书写以动词进行精准匹配，名次采用*匹配，例如getById书写成getBy\*，
  - 参数规则比较复杂，根据业务方法灵活调整
  - 通常不使用异常作为匹配规则



### AOP通知类型

- AOP通知描述了类抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置

- AOP通知共分为5种类型

  - 前置通知

  - 后置通知

  - 环绕通知（重点）

  - 返回后通知（了解）

  - 抛出异常后通知（了解）

    

- 环绕通知

  - 名称：@Around
  - 类型：方法注解
  - 位置：通知方法定义上方
  - 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行
  - 注意事项：
    - 环绕通知必须依赖行参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知
    - 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行
    - 对原始方法的调用可以不接受返回值，通知方法设置成void即可，如果接受返回值，必须设定Obiect类型
    - 原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void，也可以设置成Obiect
    - 由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出Throwable对象

### AOP通知获取数据

- 获取切入点方法的参数
  - JoinPoint：适用于前置，后置，返回后，排出异常后通知
  - ProceedJoinPoint：用于环绕通知
- 获取切入点方法返回值
  - 返回后通知
  - 环绕通知
- 获取切入点方法运行异常信息
  - 抛出异常后通知
  - 环绕通知

