

# JavaScript基础语法



#### 标识符

所谓标识符，就是指给变量、函数、属性或函数的参数起名字。

标识符可以是按照下列格式规则组合起来的一或多个字符：

- 第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）。
- 其它字符可以是字母、下划线、美元符号或数字。
- 按照惯例，ECMAScript 标识符采用驼峰命名法。
- 标识符不能是关键字和保留字符。





### 字面量和变量

#### 字面量

固定值

#### 变量

变量的作用是给某一个值或对象标注名称。

##### 变量的声明

##### 变量的赋值

##### 声明和赋值同时进行





### 数据类型

#### 类型分类

JavaScript中一共有5种基本数据类型：

- `字符串型`（String）
- `数值型`（Number）
- `布尔型`（Boolean）
- `undefined`型（Undefined）
- `null`型（Null）

> 这5种之外的类型都称为Object，所以总的来看JavaScript中共有**六种数据类型**。

#### typeof运算符

使用typeof操作符可以用来检查一个变量的数据类型。

**使用方式**

```javascript
typeof 数据
```

#### String

`String`用于表示一个字符序列，即字符串。字符串需要使用 **单引号** 或 **双引号** 括起来。

#### Number

Number 类型用来表示整数和浮点数，最常用的功能就是用来表示10进制的整数和浮点数。

Number表示的数字大小是有限的，如果超过了这个范围，则会返回 ±Infinity。

**特殊的数字：**

- Infinity：正无穷
- -Infinity：负无穷
- NaN：非法数字（Not A Number）

#### Boolean

布尔型也被称为逻辑值类型或者真假值类型。

布尔型只能够取真（true）和假（false）两种数值。除此以外， 其它的值都不被支持。

#### Undefined

Undefined 类型只有一个值，即特殊的 undefined。

在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。

#### Null

Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。

undefined值实际上是由null值衍生出来的，所以如果比较undefined和null是否相等，会返回true。





### 强制类型转换

#### 转换为String类型

将其它数值转换为字符串有三种方式：toString()、String()、 拼串。

> - null和undefined这两个值没有toString()方法，如果调用它们的方法，会报错。
> - 调用String()函数，并将被转换的数据作为参数传递给函数，使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法，但是对于null和undefined，就不会调用toString()方法，它会将 null 直接转换为 “null”，将 undefined 直接转换为 “undefined”。

#### 转换为Number类型

有三个函数可以把非数值转换为数值：Number()、parseInt() 和parseFloat()。Number()可以用来转换任意类型的数据，而后两者只能用于转换字符串。parseInt()只会将字符串转换为整数，而parseFloat()可以将字符串转换为浮点数。

- 方式一：使用Number()函数


- 字符串 --> 数字

  - 如果是纯数字的字符串，则直接将其转换为数字
  - 如果字符串中有非数字的内容，则转换为NaN
  - 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
- 布尔 --> 数字
  - true 转成 1
  - false 转成 0
- null --> 数字
  - null 转成 0
- undefined --> 数字
  - undefined 转成 NaN

> 注意：如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作







### 运算符

运算符也叫操作符，通过运算符可以对一个或多个值进行运算并获取运算结果。

#### 算术运算符

#### 关系运算符

#### 赋值运算符

#### 逻辑运算符

- &&
  - JS中的“与”属于短路的与，如果第一个值为false，则不会检查第二个值
- ||
  - JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值
- !

#### 比较运算符

比较运算符用来比较两个值是否相等，如果相等会返回true，否则返回false。

- 使用 == 来做相等运算
  - 当使用\==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后在比较
- 使用 != 来做不相等运算
  - 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false，不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false
- 使用\==\= 来做全等运算
  - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回false
- 使用 !== 来做不全等运算
  - 用来判断两个值是否不全等，它和不等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回true

#### 条件运算符

类似三目运算符

#### 逗号运算

使用逗号可以在一条语句中执行多次操作。

使用逗号运算符分隔的语句会从左到右顺 序依次执行。





### 运算符优先级





### 代码块

#### 语句

表达式和运算符等内容可以理解成是我们一门语言中的单词，短语。而语句（statement）就是我们这个语言中一句一句完整的话了。语句是一个程序的基本单位，JavaScript的程序就是由一条一条语句构成的，每一条语句使用;结尾。

JavaScript中的语句默认是由上至下顺序执行的，但是我们也可以通过一些流程控制语句来控制语句的执行顺序

#### 代码块

代码块是在大括号 {} 中所写的语句，以此将多条语句的集合视为一条语句来使用。

我们一般使用代码块将需要一起执行的语句进行分组，需要注意的是，代码块结尾不需要加 分号。





### 条件语句

#### if...else

#### Switch...case

> 注意：需要注意的是一旦符合case的条件程序会一直运行到结束，所以我们一般会在case中添加break作为语句的结束。







### 循环语句

#### while

#### do...while

#### for

#### 跳转控制

- break
- continye

可以为循环语句创建一个label，来标识当前的循环，如下例子：

```js
outer: for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (j == 5) {
            break outer;
        }
        console.log(j);
    }
}
```



### 对象基础

#### 概述

`Object`类型，我们也称为一个对象，是`JavaScript`中的引用数据类型。它是一种复合值，它将很多值聚合到一起，可以通过名字访问这些值。对象也可以看做是属性的无序集合，每个属性都是一个名/值对。对象除了可以创建自有属性，还可以通过从一个名为原型的对象那里继承属性。除了字符串、数字、`true`、`false`、`null`和`undefined`之外，JavaScript中的值都是对象。

#### 创建对象

- 第一种方式：

  - ```javascript
    var person = new Object();
    person.name = "孙悟空";
    person.age = 18;
    console.log(person);
    ```

- 第二种方式：

  - ```javascript
    var person = {
        name: "孙悟空",
        age: 18
    };
    console.log(person);
    ```

#### 访问属性

访问属性的两种方式：

- 第一种方式：使用 . 来访问

  ```javascript
  对象.属性名
  1
  ```

- 第二种方式：使用 [] 来访问

  ```javascript
  对象[‘属性名’]
  ```

#### 删除属性

删除对象的属性可以使用delete关键字，格式如下：

```javascript
delete 对象.属性名
```

#### 遍历对象

枚举遍历对象中的属性，可以使用for … in语句循环，对象中有几个属性，循环体就会执行几次。

语法格式：

```javascript
for (var 变量 in 对象) {

}
```

#### 数据类型梳理

##### 基础数据类型

##### 引用数据类型

引用类型的值是保存在内存中的对象。

当一个变量是一个对象时，实际上变量中保存的并不是对象本身，而是对象的引用。

当从一个变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中，并不是创建一个新的对象。

这时，两个变量指向的是同一个对象。因此，改变其中一个变量会影响另一个。


#### 栈和堆梳理

JavaScript在运行时数据是保存到栈内存和堆内存当中的。

简单来说栈内存用来保存变量和基本类型，堆内存是用来保存对象。





### 函数

函数是由一连串的子程序（语句的集合）所组成的，可以被外部程序调用，向函数传递参数之后，函数可以返回一定的值。

这里要注意的是JavaScript中的函数也是一个对象，使用typeof检查一个函数对象时，会返回function。

#### 函数创建

- 使用 **函数对象** 来创建一个函数（几乎不用）

  语法格式：

  ```javascript
  var 函数名 = new Function("执行语句");
  ```

- 使用 **函数声明** 来创建一个函数（比较常用）

  语法格式：

  ```javascript
  function 函数名([形参1,形参2,...,形参N]) {
      语句...
  }
  ```

- 使用 **函数表达式** 来创建一个函数（比较常用）

  语法格式：

  ```javascript
  var 函数名  = function([形参1,形参2,...,形参N]) {
      语句....
  }
  ```

#### 函数调用

- 无参函数调用
- 有参函数调用

#### 函数参数

- JS中的所有的参数传递都是按值传递的，也就是说把函数外部的值赋值给函数内部的参数，就和把值从一个变量赋值给另一个变量是一样的，在调用函数时，可以在()中指定实参（实际参数），实参将会赋值给函数中对应的形参
- 注意，是否有可能会接收到非法的参数，如果有可能，则需要对参数进行类型的检查，函数的实参可以是任意的数据类型
- 多余实参不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将是`undefined`

#### 函数返回值

可以使用 return 来设置函数的返回值，return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。

> 注意：在函数中return后的语句都不会执行，如果return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return，则也会返回undefined，return后可以跟任意类型的值
>

#### 嵌套函数

嵌套函数：在函数中声明的函数就是嵌套函数，嵌套函数只能在当前函数中可以访问，在当前函数外无法访问。

#### 匿名函数

匿名函数：没有名字的函数就是匿名函数，它可以让一个变量来接收，也就是用 “函数表达式” 方式创建和接收。

#### 立即执行函数

立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数，立即执行函数往往只会执行一次。

案例演示：

```javascript
(function () {
    alert("我是一个匿名函数");
})();
```

#### 对象中的函数

对象的属性值可以是任何的数据类型，也可以是个函数。

如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法，调用这个函数就说调用对象的方法（method）。

> 注意：方法和函数只是名称上的区别，没有其它别的区别

#### this对象

解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是`this`，`this`指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，`this`会指向不同的对象

以函数的形式调用时，`this`永远都是`window`
以方法的形式调用时，`this`就是调用方法的那个对象



### 对象进阶

#### 用工厂方法创建对象

将创建函数这个功能封装在函数中，在函数中new对象，并赋予属性,最后将对象返回

```javascript
function creatObject(){
  // 创建对象
  var obj = new Object();
  // 设置对象属性
  obj.attr1 = value1;
  obj.attr2 = value2;
  
  obj.fun1 = function(){
 		// 方法体
  }
  
  return obj;
}
```

#### 用构造函数创建对象

构造函数：构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是**构造函数习惯上首字母大写**，构造函数和普通函数的还有一个区别就是调用方式的不同，普通函数是直接调用，而**构造函数需要使用new关键字来调用**。

那构造函数是怎么执行创建对象的过程呢？我再来解释一下：

- 调用构造函数，它会立刻创建一个新的对象
- 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象
- 逐行执行函数中的代码
- 将新建的对象作为返回值返回

```javascript
function Person(name, age){
  // 设置对象属性
  this.name = name;
  this.age = age;
  
  // 设置对象方法
  this.sayName = function(){
    console.log(this.name)
  }  
}
```

构造函数有点类似工厂方法，但是它创建对象和返回对象都给我们隐藏了，使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，称为是该**类的实例**。

现在，this又出现了一种新的情况，为了不让大家混淆，我再来梳理一下：

- 当以函数的形式调用时，this是window
- 当以方法的形式调用时，谁调用方法this就是谁
- 当以构造函数的形式调用时，this就是新创建的那个对象

使用 instanceof 运算符检查一个对象是否是一个类的实例，它返回true或false

语法格式：

```javascript
对象 instanceof 构造函数
```

#### 原型

我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`，这个属性对应着一个对象，**这个对象就是我们所谓的原型对象，即显式原型**，原型对象就相当于一个公共的区域，**所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中**。

如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__（隐式原型）来访问该属性。**当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用**。

以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。

```javascript
// 使用构造函数来创建对象
function Person(name, age) {
    // 设置对象的属性
    this.name = name;
    this.age = age;
}

// 在Person类的原型对象中添加方法
Person.prototype.sayName = function() {
    console.log(this.name);
};

var person1 = new Person("孙悟空", 18);
var person2 = new Person("猪八戒", 19);
var person3 = new Person("沙和尚", 20);

person1.sayName();
person2.sayName();
person3.sayName();
```

#### 原型链

访问一个对象的属性时，先在自身属性中查找，找到返回， 如果没有，再沿着__proto__这条链向上查找，找到返回，如果最终没找到，返回undefined，这就是原型链，又称隐式原型链，它的作用就是查找对象的属性(方法)。

> 注意：Object对象是所有对象的祖宗，Object的原型对象指向为null，也就是没有原型对象

#### toString方法

toString()函数用于将当前对象以字符串的形式返回。该方法属于Object对象，由于所有的对象都"继承"了Object的对象实例，因此几乎所有的实例对象都可以使用该方法，所有主流浏览器均支持该函数。

JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。

|   类型   |                           行为描述                           |
| :------: | :----------------------------------------------------------: |
|  String  |                      返回String对象的值                      |
|  Number  |                    返回Number的字符串表示                    |
| Boolean  |       如果布尔值是true，则返回“true”。否则返回“false”        |
|  Object  |   返回"[object ObjectName]",其中ObjectName是对象类型的名称   |
|  Array   | 将Array的每个元素转换为字符串，并将他们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接 |
|   Date   |                     返回日期的文本表示。                     |
|  Error   |              返回一个包含相关错误信息的字符串。              |
| Function | 返回如下格式的字符串，其中 functionname 是一个函数的名称<br/>此函数的 toString 方法被调用： “function functionname() { [native code] }” |

#### hasOwnProperty方法

检查自身对象是否含有某个方法或属性，我们可以使用Object的hasOwnProperty()方法，它返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。

#### 对象继承

JavaScript有六种非常经典的对象继承方式，但是我们只学习前三种：

- **原型链继承**
- **借用构造函数继承**
- **组合继承（重要）**
- 原型式继承
- 寄生式继承
- 寄生组合式继承

##### 原型链继承

**核心思想**：子类型的原型为父类型的一个实例对象

**基本做法**：

- 定义父类型构造函数
- 给父类型的原型添加方法
- 定义子类型的构造函数
- 创建父类型的对象赋值给子类型的原型
- 将子类原型的构造属性设置为子类型
- 给子类原型添加方法
- 创建子类型的对象：可以调用父类型的方法

**缺点描述：**

1. 原型链继承多个实例的引用类型属性指向相同，一个实例修改了原型属性，另一个实例的原型属性也会被修改
2. 不能传递参数
3. 继承单一

##### 借用构造函数继承

**核心思想：** 使用.call()和.apply()将父类构造函数引入子类函数，使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类

**基本做法：**

1. 定义父类型构造函数
2. 定义子类型的构造函数
3. 给子类型的原型添加方法
4. 创建子类型的对象然后调用

**缺点描述：**

1. 只能继承父类的实例属性和方法，不能继承原型属性和方法
2. 无法实现构造函数的复用，每个子类都有父类实例函数的副本，影响性能，代码会臃肿

##### 组合继承

**核心思想：** 原型链+借用构造函数的组合继承

**基本做法：**

1. 利用原型链实现对父类型对象的方法继承
2. 利用super()借用父类型构建函数初始化相同属性

**缺点描述：**

1. 父类中的实例属性和方法既存在于子类的实例中，又存在于子类的原型中，不过仅是内存占用，因此，在使用子类创建实例对象时，其原型中会存在**两份相同的属性和方法** 。

#### 垃圾回收

当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。

在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们需要做的只是要将不再使用的对象设置null即可。





### 作用域

作用域指一个变量的作用的范围，在JS中一共有两种作用域：

- 全局作用域
- 函数作用域

#### 声明提前

- 变量的声明提前：**使用var关键字声明的变量，会在所有的代码执行之前被声明**（但是不会赋值），但是如果声明变量时不使用var关键字，则变量不会被声明提前
- 函数的声明提前：**使用函数声明形式创建的函数 function 函数名(){}** ，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数。使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

#### 作用域

##### 全局作用域

- 直接编写在`script`标签中的`JavaScript`代码，都在全局作用域
- 全局作用域在页面打开时创建，在页面关闭时销毁
- 在全局作用域中有一个全局对象`window`，它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用
- 在全局作用域中：
  - 创建的变量都会作为`window`对象的属性保存
  - 创建的函数都会作为`window`对象的方法保存
- 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到

##### 函数作用域

- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
- 每调用一次函数就会创建一个新的函数作用域，它们之间是互相独立的
- 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量
- 在函数中要访问全局变量可以使用window对象
- 作用域链：当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError

##### 作用域链

多个上下级关系的作用域形成的链，它的方向是从下向上的(从内到外)，查找变量时就是沿着作用域链来查找的。

查找一个变量的查找规则：

- 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2
- 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3
- 再次执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的ReferenceError异常